<?xml version="1.0"?>
<root>

	<metric name="metric_CPU operating frequency (in GHz)">
        <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
		<event alias="b">CPU_CLK_UNHALTED.REF_TSC</event>
		<constant alias="c">system.tsc_freq</constant>      
		<formula>(a/b*c)/1000000000</formula>
	</metric>

	<metric name="metric_CPU utilization %">
		<event alias="a">CPU_CLK_UNHALTED.REF_TSC</event>
		<event alias="b">TSC</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CPU utilization% in kernel mode">
		<event alias="a">CPU_CLK_UNHALTED.REF_TSC:SUP</event>
		<event alias="b">TSC</event>
		<formula>100*a/b</formula>
	</metric>

    <metric name="metric_CPI">
        <throughput-metric-name>metric_cycles per txn</throughput-metric-name>
        <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
        <event alias="b">INST_RETIRED.ANY</event>
        <formula>a/b</formula>
    </metric>

    <metric name="metric_kernel_CPI">
        <event alias="a">CPU_CLK_UNHALTED.THREAD:SUP</event>
        <event alias="b">INST_RETIRED.ANY:SUP</event>
        <formula>a/b</formula>
    </metric>

   <metric name="metric_EMON event mux reliability% (>95% good)">
        <event alias="a">CPU_CLK_UNHALTED.THREAD_P</event>
        <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
        <formula>100*(((a-b)&lt;0)?(a/b):(b/a))</formula>
    </metric>

 	<metric name="metric_branch mispredict ratio">
		<event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
		<event alias="b">BR_INST_RETIRED.ALL_BRANCHES</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_loads per instr">
        <throughput-metric-name>metric_loads per txn</throughput-metric-name>
		<event alias="a">MEM_INST_RETIRED.ALL_LOADS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_stores per instr">
        <throughput-metric-name>metric_stores per txn</throughput-metric-name>
		<event alias="a">MEM_INST_RETIRED.ALL_STORES</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>	

	<metric name="metric_locks retired per instr">
        <throughput-metric-name>metric_locks retired per txn</throughput-metric-name>
		<event alias="a">MEM_INST_RETIRED.LOCK_LOADS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>	

	<metric name="metric_streaming stores per instr">
        <throughput-metric-name>metric_streaming stores (full line) per txn</throughput-metric-name>
		<event alias="a">OCR.STREAMING_WR.ANY_RESPONSE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>	

	<metric name="metric_L1D MPI (includes data+rfo w/ prefetches)">
        <throughput-metric-name>metric_L1D misses per txn (includes data+rfo w/ prefetches)</throughput-metric-name>
		<event alias="a">L1D.REPLACEMENT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L1D demand data read hits per instr">
        <throughput-metric-name>metric_L1D demand data read hits per txn</throughput-metric-name>
		<event alias="a">MEM_LOAD_RETIRED.L1_HIT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L1-I code read misses (w/ prefetches) per instr">
        <throughput-metric-name>metric_L1I code read misses (includes prefetches) per txn</throughput-metric-name>
		<event alias="a">L2_RQSTS.ALL_CODE_RD</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2 demand data read hits per instr">
        <throughput-metric-name>metric_L2 demand data read hits per txn</throughput-metric-name>
		<event alias="a">MEM_LOAD_RETIRED.L2_HIT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2 MPI (includes code+data+rfo w/ prefetches)">
        <throughput-metric-name>metric_L2 misses per txn (includes code+data+rfo w/ prefetches)</throughput-metric-name>
		<event alias="a">L2_LINES_IN.ALL</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
	
 	<metric name="metric_L2 demand data read MPI">
        <throughput-metric-name>metric_L2 demand data read misses per txn</throughput-metric-name>
		<event alias="a">MEM_LOAD_RETIRED.L2_MISS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
	
	<metric name="metric_L2 demand code MPI">
        <throughput-metric-name>metric_L2 demand code misses per txn</throughput-metric-name>
		<event alias="a">L2_RQSTS.CODE_RD_MISS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_L2 Any local request that HITM in a sibling core (per instr)">
        <throughput-metric-name>metric_L2 Any local request that HITM in a sibling core per txn</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.L3_HIT.SNOOP_HITM</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>	

	<metric name="metric_L2 Any local request that HIT in a sibling core and forwarded(per instr)">
        <throughput-metric-name>metric_L2 Any local request that HIT in a sibling core and forwarded per txn</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.L3_HIT.SNOOP_HIT_WITH_FWD</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>

	<metric name="metric_L2 all L2 prefetches(per instr)">
        <throughput-metric-name>metric_L2 all L2 prefetches per txn</throughput-metric-name>
		<event alias="a">L2_RQSTS.ALL_HWPF</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>	
	
	<metric name="metric_L2 % of all lines evicted that are unused prefetches">
		<event alias="a">L2_LINES_OUT.USELESS_HWPF</event>
		<event alias="b">L2_LINES_OUT.NON_SILENT</event>
		<event alias="c">L2_LINES_OUT.SILENT</event>
		<constant alias="threads">system.sockets[0][0].size</constant>      
		<formula>100*a/(b+(c/threads))</formula>
	</metric>

	<metric name="metric_L2 % of L2 evictions that are allocated into L3">
		<event alias="a">L2_LINES_OUT.NON_SILENT</event>
		<event alias="b">IDI_MISC.WB_DOWNGRADE</event>
		<formula>100*(a-b)/a</formula>
	</metric>

	<metric name="metric_L2 % of L2 evictions that are NOT allocated into L3">
		<event alias="a">L2_LINES_OUT.NON_SILENT</event>
		<event alias="b">IDI_MISC.WB_DOWNGRADE</event>
		<formula>100*b/a</formula>
	</metric>

	<metric name="metric_Load_L2_Miss_Latency_using_ORO_events(ns)">
		<event alias="a">OFFCORE_REQUESTS_OUTSTANDING.DEMAND_DATA_RD</event>
		<event alias="b">OFFCORE_REQUESTS.DEMAND_DATA_RD</event>		
        <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
        <event alias="d">CPU_CLK_UNHALTED.REF_TSC</event>
        <constant alias="e">system.tsc_freq</constant>
        <formula>1000000000*(a/b)/(c/d*e)</formula>
	</metric>	

	<metric name="metric_LLC code references hit in LLC per instr (prefetches included)">
        <throughput-metric-name>metric_LLC code references hit in LLC per txn (prefetches included)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_HIT_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_HIT_CRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_HIT_CRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC data read references hit in LLC per instr (prefetches included)">
        <throughput-metric-name>metric_LLC data read references hit in LLC per txn (prefetches included)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_HIT_LLCPREFDRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_HIT_DRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_HIT_DRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC RFO references hit in LLC per instr (prefetches included)">
        <throughput-metric-name>metric_LLC RFO references hit in LLC per txn (prefetches included)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_HIT_LLCPREFRFO</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_HIT_RFO</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_HIT_RFO_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC MPI (includes code+data+rfo w/ prefetches)">
        <throughput-metric-name>metric_LLC misses per txn (includes code+data+rfo w/ prefetches)</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_CRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_CRD_PREF</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDRD</event>
		<event alias="e">UNC_CHA_TOR_INSERTS.IA_MISS_DRD</event>
		<event alias="f">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF</event>
		<event alias="g">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="h">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
		<event alias="j">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF</event>
		<event alias="k">INST_RETIRED.ANY</event>
		<formula>(a+b+c+d+e+f+g+h+j)/k</formula>
	</metric>

	<metric name="metric_LLC data read MPI (demand+prefetch)">
        <throughput-metric-name>metric_LLC data read (demand+prefetch) misses per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC RFO read MPI (demand+prefetch)">
        <throughput-metric-name>metric_LLC RFO read (demand+prefetch) misses per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC code read MPI (demand+prefetch)">
        <throughput-metric-name>metric_LLC code read (demand+prefetch) misses per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_CRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_CRD_PREF</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC all LLC prefetches (per instr)">
        <throughput-metric-name>metric_LLC LLC prefetches per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFCRD</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDRD</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_LLC total HITM (per instr) (excludes LLC prefetches)">
        <throughput-metric-name>metric_LLC total HITM per txn (excludes LLC prefetches)</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.REMOTE_CACHE.SNOOP_HITM</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_LLC total HIT clean line forwards (per instr) (excludes LLC prefetches)">
        <throughput-metric-name>metric_LLC total HIT clean line forwards per txn (excludes LLC prefetches)</throughput-metric-name>
		<event alias="a">OCR.ALL_REQUESTS.REMOTE_CACHE.SNOOP_HIT_WITH_FWD</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
    
	<metric name="metric_Load_L3_Miss_Latency_using_ORO_events(ns)">
		<event alias="a">OFFCORE_REQUESTS_OUTSTANDING.L3_MISS_DEMAND_DATA_RD</event>
		<event alias="b">OFFCORE_REQUESTS.L3_MISS_DEMAND_DATA_RD</event>		
        <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
        <event alias="d">CPU_CLK_UNHALTED.REF_TSC</event>
        <constant alias="e">system.tsc_freq</constant>
        <formula>1000000000*(a/b)/(c/d*e)</formula>
	</metric>	

    <metric name="metric_Average LLC demand data read miss latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

    <metric name="metric_Average LLC demand RFO miss latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_RFO</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula> 
    </metric>

    <metric name="metric_Average LLC demand data read miss latency for LOCAL requests (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_LOCAL</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_LOCAL</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

	<metric name="metric_Average LLC demand data read miss latency for REMOTE requests (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_REMOTE</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_REMOTE</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

     <metric name="metric_Average LLC demand data read miss to DCPMEM latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_PMM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PMM</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

    <metric name="metric_Average LLC demand data read miss to DRAM latency (in ns)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_DRAM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_DRAM</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

	<metric name="metric_LLC % SpecI2M  vs total Ownership req)">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_SPECITOM</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF</event>
		<formula>(a)/(a+b+c+d)</formula>
	</metric>

    <metric name="metric_TOR DRD miss avg entries (demand+prefetch)">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD</event>
		<event alias="b">UNC_CHA_TOR_OCCUPANCY.IA_MISS_LLCPREFDRD</event>
		<event alias="c">UNC_CHA_TOR_OCCUPANCY.IA_MISS_DRD_PREF</event>
        <event alias="d">UNC_CHA_CLOCKTICKS</event>
        <formula>(a+b+c)/d</formula>
    </metric>
    
    <metric name="metric_TOR ALL avg entries ">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.ALL:umask_ext=0xC001FF</event>
        <event alias="d">UNC_CHA_CLOCKTICKS</event>
        <formula>a/d</formula>
    </metric>

    <metric name="metric_TOR LOCtoLOC avg entries ">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.LOC_ALL:umask_ext=0xC000FF</event>
        <event alias="d">UNC_CHA_CLOCKTICKS</event>
        <formula>a/d</formula>
    </metric>

    <metric name="metric_TOR LOCtoREM avg entries ">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.LOC_ALL:umask_ext=0xC0017F</event>
        <event alias="d">UNC_CHA_CLOCKTICKS</event>
        <formula>a/d</formula>
    </metric>

    <metric name="metric_TOR REM avg entries ">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.REM_ALL:umask_ext=0xC001FF</event>
        <event alias="d">UNC_CHA_CLOCKTICKS</event>
        <formula>a/d</formula>
    </metric>

    <metric name="metric_TOR RFO miss avg entries (demand+prefetch">
        <event alias="a">UNC_CHA_TOR_OCCUPANCY.IA_MISS_RFO</event>
		<event alias="b">UNC_CHA_TOR_OCCUPANCY.IA_MISS_LLCPREFRFO</event>
		<event alias="c">UNC_CHA_TOR_OCCUPANCY.IA_MISS_RFO_PREF</event>
        <event alias="d">UNC_CHA_CLOCKTICKS</event>
        <formula>(a+b+c)/d</formula>
    </metric>


	<metric name="metric_SF snoop filter capacity evictions (per instr)">
        <throughput-metric-name>metric_SF snoop filter capacity evictions per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_SF_EVICTION.M_STATE</event>
		<event alias="b">UNC_CHA_SF_EVICTION.S_STATE</event>
		<event alias="c">UNC_CHA_SF_EVICTION.E_STATE</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
	</metric>

	<metric name="metric_SF % of L3 accesses that result in SF capacity evictions">
		<event alias="a">UNC_CHA_SF_EVICTION.M_STATE</event>
		<event alias="b">UNC_CHA_SF_EVICTION.S_STATE</event>
		<event alias="c">UNC_CHA_SF_EVICTION.E_STATE</event>
		<event alias="d">L2_LINES_IN.ALL</event>
		<formula>100*(a+b+c)/d</formula>
	</metric>

	<metric name="metric_ITLB (2nd level) MPI">
        <throughput-metric-name>metric_ITLB (2nd level) misses per txn</throughput-metric-name>
		<event alias="a">ITLB_MISSES.WALK_COMPLETED</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_ITLB (2nd level) large page MPI">
        <throughput-metric-name>metric_ITLB (2nd level) large page misses per txn</throughput-metric-name>
		<event alias="a">ITLB_MISSES.WALK_COMPLETED_2M_4M</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_STLB data page hits per instr">
        <throughput-metric-name>metric_STLB data page hits per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.STLB_HIT</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB (2nd level) load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB (2nd level) 4KB page load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) 4KB page load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED</event>
		<event alias="b">DTLB_LOAD_MISSES.WALK_COMPLETED_2M_4M</event>
		<event alias="c">DTLB_LOAD_MISSES.WALK_COMPLETED_1G</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a-b-c)/d</formula>
	</metric>
	
	<metric name="metric_DTLB (2nd level) 2MB large page load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) 2MB large page load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED_2M_4M</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB (2nd level) 1GB large page load MPI">
        <throughput-metric-name>metric_DTLB (2nd level) 1GB large page load misses per txn</throughput-metric-name>
		<event alias="a">DTLB_LOAD_MISSES.WALK_COMPLETED_1G</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
	
	<metric name="metric_DTLB (2nd level) store MPI">
        <throughput-metric-name>metric_DTLB (2nd level) store misses per txn</throughput-metric-name>
		<event alias="a">DTLB_STORE_MISSES.WALK_COMPLETED</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB load miss latency (in core clks)">
		<event alias="a">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
		<event alias="b">DTLB_LOAD_MISSES.WALK_COMPLETED</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DTLB store miss latency (in core clks)">
		<event alias="a">DTLB_STORE_MISSES.WALK_ACTIVE</event>
		<event alias="b">DTLB_STORE_MISSES.WALK_COMPLETED</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_ITLB miss latency (in core clks)">
		<event alias="a">ITLB_MISSES.WALK_ACTIVE</event>
		<event alias="b">ITLB_MISSES.WALK_COMPLETED</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_NUMA %_Reads addressed to local DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_REMOTE</event>
		<formula>100*(a+b)/(a+b+c+d)</formula>
	</metric>

	<metric name="metric_NUMA %_Reads addressed to remote DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_REMOTE</event>
		<formula>100*(c+d)/(a+b+c+d)</formula>
	</metric>
	
	<metric name="metric_NUMA %_RFOs addressed to local DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_REMOTE</event>
		<formula>100*(a+b)/(a+b+c+d)</formula>
	</metric>

	<metric name="metric_NUMA %_RFOs addressed to remote DRAM">
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_LOCAL</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_LOCAL</event>
		<event alias="c">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_REMOTE</event>
		<event alias="d">UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_REMOTE</event>
		<formula>100*(c+d)/(a+b+c+d)</formula>
	</metric>

	<metric name="metric_uncore frequency GHz">
        <event alias="a">UNC_CHA_CLOCKTICKS</event>
        <constant alias="b">system.cha_count/system.socket_count</constant>
        <constant alias="socket_count">system.socket_count</constant>
        <formula>a/(b*socket_count)/1000000000</formula>
        <formula socket="0">a[0]/b/1000000000</formula>
        <formula socket="1">a[1]/b/1000000000</formula>
    </metric>

     <metric name="metric_UPI speed - GT/s">
        <constant alias="socket_count">system.socket_count</constant>
        <constant alias="links_per_socket">3</constant>
        <event alias="a">UNC_UPI_CLOCKTICKS</event>
        <event alias="tsc">TSC</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <event alias="c6">MSR_EVENT:msr=0x3F9:type=FREERUN:scope=PACKAGE</event>
       <constant alias="d">system.sockets[0].cores.count</constant>
  		<constant alias="threads">system.sockets[0][0].size</constant>      
        <formula>(((tsc/(d*threads)) / ((tsc/(d*threads)) - c6))*(a-f))  /(socket_count*links_per_socket)*8/1000000000</formula>
        <formula socket="0">((tsc/(d*threads)) / ((tsc/(d*threads)) - c6[0])*(a[0]-f[0]))/links_per_socket*8/1000000000</formula>
        <formula socket="1">((tsc/(d*threads)) / ((tsc/(d*threads)) - c6[1])*(a[1]-f[1]))/links_per_socket*8/1000000000</formula>
    </metric>

    <metric name="metric_UPI Data transmit BW (MB/sec) (only data)">
        <event alias="a">UNC_UPI_TxL_FLITS.ALL_DATA</event>
       <!-- 9 flits are needed to transmit a full cache line -->
        <formula>a*(64/9)/1000000</formula>
    </metric>

    <metric name="metric_UPI Transmit utilization_% (includes control)">
       <constant alias="socket_count">system.socket_count</constant>
        <constant alias="links_per_socket">3</constant>
        <event alias="a">UNC_UPI_CLOCKTICKS</event>
        <event alias="tsc">TSC</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <event alias="c6">MSR_EVENT:msr=0x3F9:type=FREERUN:scope=PACKAGE</event>
        <event alias="g">UNC_UPI_TxL_FLITS.ALL_DATA</event>
        <event alias="h">UNC_UPI_TxL_FLITS.NON_DATA</event>
       <constant alias="d">system.sockets[0].cores.count</constant>
  		<constant alias="threads">system.sockets[0][0].size</constant>      
        <!-- 5 flits are sent in every 6 clocks; NULL flits are sent across all 3 slots and hence b/3 -->
		<!-- So useful flits (non-idle) == (clocks*5/6) - (null_flits/3) -->	
        <formula>100*((g+h)/3)/(((((tsc/(d*threads)) / ((tsc/(d*threads)) - c6))*(a-f))*5/6))</formula>
    </metric>

    <metric name="metric_UPI % cycles transmit link is half-width (L0p)">
        <event alias="a">UNC_UPI_TxL0P_POWER_CYCLES</event>
        <event alias="b">UNC_UPI_CLOCKTICKS</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <formula>100*(a/(b-f))</formula>
    </metric>

    <metric name="metric_UPI % cycles receive link is half-width (L0p)">
        <event alias="a">UNC_UPI_RxL0P_POWER_CYCLES</event>
        <event alias="b">UNC_UPI_CLOCKTICKS</event>
        <event alias="f">UNC_UPI_L1_POWER_CYCLES</event>
        <formula>100*(a/(b-f))</formula>
    </metric>

    <metric name="metric_HA - Reads vs. all requests">
      <event alias="a">UNC_CHA_REQUESTS.READS_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.WRITES_LOCAL</event>
      <event alias="c">UNC_CHA_REQUESTS.READS_REMOTE</event>
      <event alias="d">UNC_CHA_REQUESTS.WRITES_REMOTE</event>
      <formula>(a+c)/(a+b+c+d)</formula>
    </metric>

    <metric name="metric_HA - Writes vs. all requests">
      <event alias="a">UNC_CHA_REQUESTS.READS_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.WRITES_LOCAL</event>
      <event alias="c">UNC_CHA_REQUESTS.READS_REMOTE</event>
      <event alias="d">UNC_CHA_REQUESTS.WRITES_REMOTE</event>
      <formula>(b+d)/(a+b+c+d)</formula>
    </metric>

    <metric name="metric_HA % of all reads that are local">
      <event alias="a">UNC_CHA_REQUESTS.READS_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.READS_REMOTE</event>
      <formula>100*a/(a+b)</formula>
    </metric>

    <metric name="metric_HA % of all writes that are local">
      <event alias="a">UNC_CHA_REQUESTS.WRITES_LOCAL</event>
      <event alias="b">UNC_CHA_REQUESTS.WRITES_REMOTE</event>
      <formula>100*a/(a+b)</formula>
    </metric>

    <metric name="metric_HA conflict responses per instr">
        <throughput-metric-name>metric_HA conflict responses per txn</throughput-metric-name>
      <event alias="a">UNC_CHA_SNOOP_RESP.RSPCNFLCTS</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
    </metric>

    <metric name="metric_HA directory lookups that spawned a snoop (per instr)">
        <throughput-metric-name>metric_HA directory lookups that spawned a snoop (per txn)</throughput-metric-name>
      <event alias="a">UNC_CHA_DIR_LOOKUP.SNP</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
    </metric>

    <metric name="metric_HA directory lookups that did not spawn a snoop (per instr)">
        <throughput-metric-name>metric_HA directory lookups that did not spawn a snoop (per txn)</throughput-metric-name>
      <event alias="a">UNC_CHA_DIR_LOOKUP.NO_SNP</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
    </metric>

    <metric name="metric_M2M directory updates (per instr)">
        <throughput-metric-name>metric_M2M directory updates (per txn)</throughput-metric-name>
		<event alias="a">UNC_CHA_DIR_UPDATE.HA</event>
		<event alias="b">UNC_CHA_DIR_UPDATE.TOR</event>
		<event alias="c">UNC_M2M_DIRECTORY_UPDATE.ANY</event>
		<event alias="d">INST_RETIRED.ANY</event>
		<formula>(a+b+c)/d</formula>
    </metric>

    <metric name="metric_M2M XPT prefetches (per instr)">
        <throughput-metric-name>metric_M2M XPT prefetches (per txn)</throughput-metric-name>
		<event alias="a">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
    </metric>
	
    <metric name="metric_M3UPI UPI prefetches (per instr)">
        <throughput-metric-name>metric_M3UPI UPI prefetches (per txn)</throughput-metric-name>
		<event alias="a">UNC_M2M_PREFCAM_INSERTS.UPI_ALLCH</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
    </metric>
	
    <metric name="metric_M2M extra reads from XPT-UPI prefetches (per instr)">
        <throughput-metric-name>metric_M2M useless XPT-UPI prefetches (per txn)</throughput-metric-name>
		<event alias="a">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
		<event alias="b">UNC_M2M_PREFCAM_INSERTS.UPI_ALLCH</event>
		<event alias="c">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
		<event alias="d">UNC_M2M_PREFCAM_DEMAND_MERGE.UPI_ALLCH</event>
		<event alias="e">INST_RETIRED.ANY</event>
		<formula>((a+b)-(c+d))/e</formula>
    </metric>
	
    <metric name="metric_DDR data rate (MT/sec)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <constant alias="socket_count">system.socket_count</constant>
        <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <formula>2*a/(socket_count*channels_populated_per_socket)/1000000</formula>
        <formula socket="0">2*a[0]/channels_populated_per_socket/1000000</formula>
	 	<formula socket="1">2*a[1]/channels_populated_per_socket/1000000</formula>
     </metric>

    <metric name="metric_memory bandwidth read (MB/sec)">
        <event alias="a">UNC_M_CAS_COUNT.RD</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_memory bandwidth write (MB/sec)">
        <event alias="a">UNC_M_CAS_COUNT.WR</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_memory bandwidth total (MB/sec)">
        <event alias="a">UNC_M_CAS_COUNT.RD</event>
        <event alias="b">UNC_M_CAS_COUNT.WR</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_memory extra write b/w due to directory updates (MB/sec)">
		<event alias="a">UNC_CHA_DIR_UPDATE.HA</event>
		<event alias="b">UNC_CHA_DIR_UPDATE.TOR</event>
		<event alias="c">UNC_M2M_DIRECTORY_UPDATE.ANY</event>
        <formula>(a+b+c)*64/1000000</formula>
    </metric>

    <metric name="metric_memory extra read b/w due to XPT/UPI prefetches (MB/sec)">
        <event alias="a">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <event alias="b">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_INSERTS.UPI_ALLCH</event>
        <event alias="d">UNC_M2M_PREFCAM_DEMAND_MERGE.UPI_ALLCH</event>
        <formula>(a-b+c-d)*64/1000000</formula>
    </metric>
	
    <metric name="metric_DCPMEM_memory_mode near memory cache read miss rate%">
		<event alias="a">UNC_M_TAGCHK.HIT</event>
		<event alias="b">UNC_M_TAGCHK.MISS_CLEAN</event>
		<event alias="c">UNC_M_TAGCHK.MISS_DIRTY</event>
        <formula>100*(b+c)/(a+b+c)</formula>
    </metric>
	
    <metric name="metric_memory RPQ PCH0 read latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_RPQ_INSERTS.PCH0</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>
	
    <metric name="metric_memory RPQ PCH1 read latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_RPQ_INSERTS.PCH1</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH1</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>

    <metric name="metric_memory avg entries in RPQ">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_RPQ_OCCUPANCY_PCH0</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH1</event>
       <formula>(b+c)/(a/2)</formula>
    </metric>

    <metric name="metric_memory avg entries in RPQ when not empty">
        <event alias="a">UNC_M_RPQ_OCCUPANCY_PCH0</event>
        <event alias="b">UNC_M_RPQ_CYCLES_NE.PCH0</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH1</event>
        <event alias="d">UNC_M_RPQ_CYCLES_NE.PCH1</event>
       <formula>(a/b)+(c/d)</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_CYCLES_NE.PCH0</event>
       <formula>100*(1-c/(a/2))</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_CYCLES_NE.PCH0</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	<metric name="metric_memory % cycles when RPQ PCH0 has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0:t=10</event>
       <formula>100*c/(a/2)</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 has 20 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0:t=20</event>
       <formula>100*c/(a/2)</formula>
    </metric>

	<metric name="metric_memory % cycles when RPQ PCH0 has 30 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_OCCUPANCY_PCH0:t=30</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	
<!-- seems to be broken
	<metric name="metric_memory % cycles when RPQ is full">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_RPQ_CYCLES_FULL_PCH0</event>
       <formula>100*c/(a/2)</formula>
    </metric>
-->
    <metric name="metric_memory WPQ PCH0 write latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_WPQ_INSERTS.PCH0</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>
	
    <metric name="metric_memory WPQ PCH1 write latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_WPQ_INSERTS.PCH1</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH1</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula>
    </metric>

    <metric name="metric_memory avg entries in WPQ">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_WPQ_OCCUPANCY_PCH0</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH1</event>
       <formula>(b+c)/(a/2)</formula>
    </metric>

    <metric name="metric_memory avg entries in WPQ when not empty">
        <event alias="a">UNC_M_WPQ_OCCUPANCY_PCH0</event>
        <event alias="b">UNC_M_WPQ_CYCLES_NE.PCH0</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH1</event>
        <event alias="d">UNC_M_WPQ_CYCLES_NE.PCH1</event>
       <formula>(a/b)+(c/d)</formula>
    </metric>

	<metric name="metric_memory % cycles when WPQ PCH0 is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_CYCLES_NE.PCH0</event>
       <formula>100*(1-c/(a/2))</formula>
    </metric>

	<metric name="metric_memory % cycles when WPQ PCH0 has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_CYCLES_NE.PCH0</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	<metric name="metric_memory % cycles when WPQ PCH0 has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0:t=10</event>
       <formula>100*c/(a/2)</formula>
    </metric>

	<metric name="metric_memory % cycles when WPQ PCH0 has 20 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0:t=20</event>
       <formula>100*c/(a/2)</formula>
    </metric>

	<metric name="metric_memory % cycles when WPQ PCH0 has 30 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_WPQ_OCCUPANCY_PCH0:t=30</event>
       <formula>100*c/(a/2)</formula>
    </metric>
	
    <metric name="metric_3DXP_memory bandwidth read (MB/sec)">
        <event alias="a">UNC_M_DDRT_RPQ_INSERTS</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_3DXP_memory bandwidth write (MB/sec)">
        <event alias="a">UNC_M_DDRT_WPQ_INSERTS</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_3DXP_memory bandwidth total (MB/sec)">
        <event alias="a">UNC_M_DDRT_RPQ_INSERTS</event>
        <event alias="b">UNC_M_DDRT_WPQ_INSERTS</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_3DXP memory RPQ read latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_RPQ_INSERTS</event>
        <event alias="c">UNC_M_DDRT_RPQ_OCCUPANCY.ALL</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula> 
    </metric>

    <metric name="metric_3DXP avg entries in RPQ">
        <event alias="b">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_DDRT_RPQ_OCCUPANCY.ALL</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>c/((b/2)*aep_dimms_per_socket/channels_populated_per_socket)</formula>
    </metric>
	
    <metric name="metric_3DXP avg entries in RPQ when not empty">
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_DDRT_RPQ_OCCUPANCY.ALL</event>
       <formula>c/b</formula>
    </metric>

    <metric name="metric_3DXP % cycles when RPQ is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=1</event>
      <formula>100*(1-(b/(a/2)))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=1</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=10</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 24 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=24</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when RPQ has 36 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=36</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) RPQ not empty">
        <event alias="a">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=1</event>
       <formula>b/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) RPQ empty">
        <event alias="a">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constants below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>(((c/2)*aep_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with 36 or more entries in RPQ">
        <event alias="a">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=36:e1</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=36</event>
       <formula>b/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with less than 36 entries in RPQ">
        <event alias="a">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=36:e1</event>
        <event alias="b">UNC_M_DDRT_RPQ_OCCUPANCY.ALL:t=36</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>(((c/2)*aep_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>
	
	<metric name="metric_3DXP memory WPQ write latency (ns)">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_WPQ_INSERTS</event>
        <event alias="c">UNC_M_DDRT_WPQ_OCCUPANCY.ALL</event>
        <constant alias="socket_count">system.socket_count</constant>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
       <formula>((c/b)/((a/2)/(socket_count*channels_populated_per_socket)))*1000000000</formula>
       <formula socket="0">((c[0]/b[0])/((a[0]/2)/(channels_populated_per_socket)))*1000000000</formula>
       <formula socket="1">((c[1]/b[1])/((a[1]/2)/(channels_populated_per_socket)))*1000000000</formula> 
    </metric>
	
    <metric name="metric_3DXP avg entries in WPQ">
        <event alias="b">UNC_M_CLOCKTICKS</event>
        <event alias="c">UNC_M_DDRT_WPQ_OCCUPANCY.ALL</event>
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>c/((b/2)*aep_dimms_per_socket/channels_populated_per_socket)</formula>
    </metric>
	
    <metric name="metric_3DXP avg entries in WPQ when not empty">
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_DDRT_WPQ_OCCUPANCY.ALL</event>
       <formula>c/b</formula>
    </metric>
	
   <metric name="metric_3DXP % cycles when WPQ has 1 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=1</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when WPQ has 10 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=10</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
      <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>
	
    <metric name="metric_3DXP % cycles when WPQ is empty">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=1</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>100*(1-(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket)))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when WPQ has 20 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=20</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
      <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP % cycles when WPQ has 30 or more entries">
        <event alias="a">UNC_M_CLOCKTICKS</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=30</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
      <formula>100*(b/((a/2)*aep_dimms_per_socket/channels_populated_per_socket))</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) WPQ not empty">
        <event alias="a">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=1</event>
       <formula>b/a</formula>
    </metric>
	
   <metric name="metric_3DXP avg time (dclk) WPQ empty">
        <event alias="a">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=1:e1</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=1</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>(((c/2)*aep_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with 30 or more entries in WPQ">
        <event alias="a">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=30:e1</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=30</event>
       <formula>b/a</formula>
    </metric>

   <metric name="metric_3DXP avg time (dclk) with less than 30 entries in WPQ">
        <event alias="a">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=30:e1</event>
        <event alias="b">UNC_M_DDRT_WPQ_OCCUPANCY.ALL:t=30</event>
        <event alias="c">UNC_M_CLOCKTICKS</event>
         <!-- Assumed 6 memory channels populated in each socket; if not change the constant below -->
        <constant alias="channels_populated_per_socket">8</constant>
        <constant alias="aep_dimms_per_socket">6</constant>
       <formula>(((c/2)*aep_dimms_per_socket/channels_populated_per_socket)-b)/a</formula>
    </metric>

	<metric name="metric_CHA % OSB Loc InvItoE">
		<event alias="a">UNC_CHA_OSB.LOCAL_INVITOE</event>
        <event alias="b">UNC_CHA_REQUESTS.INVITOE_LOCAL</event>
		<formula>100*a/b</formula>
	</metric>

    <!--
	<metric name="metric_CHA % OSB Rem InvItoE">
		<event alias="a">UNC_CHA_OSB.REMOTE_READINVITOE</event>
        <event alias="b">UNC_CHA_REQUESTS.INVITOE_REMOTE</event>
		<formula>100*a/b</formula>
	</metric>
    -->

	<metric name="metric_CHA % OSB Loc Read">
		<event alias="a">UNC_CHA_OSB.LOCAL_READ</event>
        <event alias="b">UNC_CHA_REQUESTS.READS_LOCAL</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CHA % OSB Rem Read">
		<event alias="a">UNC_CHA_OSB.REMOTE_READ</event>
        <event alias="b">UNC_CHA_REQUESTS.READS_REMOTE</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_CHA % cyles Fast asserted">
		<event alias="a">UNC_CHA_DISTRESS_ASSERTED.VERT</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
		<formula>100*a/c</formula>
	</metric>
	
	<metric name="metric_CHA % cyles Fast asserted for dynamic prefetch throttle">
		<event alias="a">UNC_CHA_DISTRESS_ASSERTED.DPT_LOCAL</event>
		<event alias="b">UNC_CHA_DISTRESS_ASSERTED.DPT_NONLOCAL</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
		<formula>100*(a+b)/c</formula>
	</metric>
	
    <metric name="metric_CHA RxC IRQ latency (ns)">
        <event alias="a">UNC_CHA_RxC_OCCUPANCY.IRQ</event>
        <event alias="b">UNC_CHA_RxC_INSERTS.IRQ</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
    <metric name="metric_CHA RxC IRQ avg entries">
        <event alias="a">UNC_CHA_RxC_OCCUPANCY.IRQ</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
        <formula>a/c</formula>
    </metric>
	
    <metric name="metric_CHA RxC IRQ % cycles when Q has 18 or more entries">
        <event alias="a">UNC_CHA_CLOCKTICKS</event>
        <event alias="c">UNC_CHA_RxC_OCCUPANCY.IRQ:t=18</event>
       <formula>100*c/a</formula>
    </metric>
    
    <metric name="metric_M2M Rd Trk avg entries">
        <event alias="a">UNC_M2M_TRACKER_OCCUPANCY.CH0</event>
        <event alias="b">UNC_M2M_TRACKER_OCCUPANCY.CH1</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>((a+b)/mcs_populated_per_socket)/(c/(d*socket_count))</formula>
        <formula socket="0">((a[0]+b[0])/mcs_populated_per_socket)/(c[0]/d)</formula>
        <formula socket="1">((a[1]+b[1])/mcs_populated_per_socket)/(c[1]/d)</formula>
    </metric>

    <metric name="metric_M2M Rd Trk CH0 Latency (ns)">
        <event alias="a">UNC_M2M_TRACKER_OCCUPANCY.CH0</event>
        <event alias="b">UNC_M2M_TRACKER_INSERTS.CH0</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
    
    <metric name="metric_M2M Rd Trk CH1 Latency (ns)">
        <event alias="a">UNC_M2M_TRACKER_OCCUPANCY.CH1</event>
        <event alias="b">UNC_M2M_TRACKER_INSERTS.CH1</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
    
    <metric name="metric_M2M TxC AD latency (ns)">
        <event alias="a">UNC_M2M_TxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_M2M_TxC_AD_INSERTS</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
    <metric name="metric_M2M TxC BL latency (ns)">
        <event alias="a">UNC_M2M_TxC_BL_OCCUPANCY.ALL</event>
        <event alias="b">UNC_M2M_TxC_BL_INSERTS.ALL</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
	
    <metric name="metric_M2M TxC AD avg entries">
        <event alias="a">UNC_M2M_TxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M TxC BL avg entries">
        <event alias="a">UNC_M2M_TxC_BL_OCCUPANCY.ALL</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M RxC AD latency (ns)">
        <event alias="a">UNC_M2M_RxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_M2M_RxC_AD_INSERTS</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>

    <metric name="metric_M2M RxC BL latency (ns)">
        <event alias="a">UNC_M2M_RxC_BL_OCCUPANCY</event>
        <event alias="b">UNC_M2M_RxC_BL_INSERTS</event>
        <event alias="c">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="d">system.cha_count/system.socket_count</constant>
         <formula>1000000000*(a/b)/(c/(d*socket_count))</formula>
        <formula socket="0">1000000000*(a[0]/b[0])/(c[0]/d)</formula>
        <formula socket="1">1000000000*(a[1]/b[1])/(c[1]/d)</formula>
    </metric>
	
    <metric name="metric_M2M RxC AD avg entries">
        <event alias="a">UNC_M2M_RxC_AD_OCCUPANCY</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M RxC BL avg entries">
        <event alias="a">UNC_M2M_RxC_BL_OCCUPANCY</event>
        <event alias="b">UNC_CHA_CLOCKTICKS</event>
       <constant alias="socket_count">system.socket_count</constant>
		<!-- The following formula should automatically compute the number of active CHA/cache slices,
			even when some cores are offlined -->
       <constant alias="c">system.cha_count/system.socket_count</constant>
        <constant alias="mcs_populated_per_socket">4</constant>
        <formula>(a/mcs_populated_per_socket)/(b/(c*socket_count))</formula>
        <formula socket="0">(a[0]/mcs_populated_per_socket)/(b[0]/(c))</formula>
        <formula socket="1">(a[1]/mcs_populated_per_socket)/(b[1]/(c))</formula>
    </metric>

    <metric name="metric_M2M XPT land ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <event alias="e">UNC_M2M_PREFCAM_DEMAND_DROPS.XPT_ALLCH</event>
        <event alias="g">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <formula>(e+g)/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT fwd ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event> 
        <event alias="e">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <formula>(e)/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT drop ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <event alias="e">UNC_M2M_PREFCAM_DEMAND_DROPS.XPT_ALLCH</event>
        <formula>e/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT useful ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <formula>(a)/(a+c)</formula>
    </metric>
	
    <metric name="metric_M2M XPT waste ratio">
        <event alias="a">UNC_M2M_PREFCAM_DEMAND_MERGE.XPT_ALLCH</event>
        <event alias="c">UNC_M2M_PREFCAM_DEMAND_NO_MERGE.XPT_ALLCH</event>
        <event alias="e">UNC_M2M_PREFCAM_INSERTS.XPT_ALLCH</event>
        <formula>(e-a)/(a+c)</formula>
    </metric>

    <metric name="metric_IO_bandwidth_disk_or_network_writes (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_HIT_RDCUR</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_RDCUR</event>
         <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_IO_bandwidth_disk_or_network_reads (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_HIT_ITOM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_ITOM</event>
        <event alias="c">UNC_CHA_TOR_INSERTS.IO_HIT_ITOMCACHENEAR</event>
        <event alias="d">UNC_CHA_TOR_INSERTS.IO_MISS_ITOMCACHENEAR</event>
         <formula>(a+b+c+d)*64/1000000</formula>
    </metric>

    <metric name="metric_IO_number of partial PCI writes per sec">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_HIT_ITOMCACHENEAR</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_ITOMCACHENEAR</event>
        <formula>a+b</formula>
    </metric>

    <metric name="metric_IO_read cache miss(disk/network writes) bandwidth (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_MISS_RDCUR</event>
        <formula>a*64/1000000</formula>
    </metric>

    <metric name="metric_IO_write cache miss(disk/network reads) bandwidth (MB/sec)">
        <event alias="a">UNC_CHA_TOR_INSERTS.IO_MISS_ITOM</event>
        <event alias="b">UNC_CHA_TOR_INSERTS.IO_MISS_ITOMCACHENEAR</event>
        <formula>(a+b)*64/1000000</formula>
    </metric>

    <metric name="metric_memory reads vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.RD</event>
        <event alias="b">UNC_M_CAS_COUNT.WR</event>
        <formula>a/(a+b)</formula>
    </metric>

    <metric name="metric_memory Page Empty vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.ALL</event>
        <event alias="b">UNC_M_ACT_COUNT.ALL</event>
        <event alias="c">UNC_M_PRE_COUNT.ALL</event>
        <event alias="d">UNC_M_PRE_COUNT.PGT</event>
        <formula>(b*d)/(a*c)</formula>
    </metric>

    <metric name="metric_memory Page Misses vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.ALL</event>
        <event alias="b">UNC_M_ACT_COUNT.ALL</event>
        <event alias="c">UNC_M_PRE_COUNT.ALL</event>
        <event alias="d">UNC_M_PRE_COUNT.PGT</event>
        <formula>(b*(c-d))/(a*c)</formula>
    </metric>

    <metric name="metric_memory Page Hits vs. all requests">
        <event alias="a">UNC_M_CAS_COUNT.ALL</event>
        <event alias="b">UNC_M_ACT_COUNT.ALL</event>
        <formula>(a-b)/a</formula>
    </metric>

    <metric name="metric_ItoM operations (fast strings) that reference LLC per instr">
        <throughput-metric-name>metric_ItoM operations (fast strings) that reference LLC per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_ITOM</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_SPECITOM</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>(a+b)/c</formula>
	</metric>
		
    <metric name="metric_% Uops delivered from decoded Icache (DSB)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(a/(a+b+c+d))</formula>
    </metric>

    <metric name="metric_% Uops delivered from legacy decode pipeline (MITE)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(b/(a+b+c+d))</formula>
    </metric>

    <metric name="metric_% Uops delivered from microcode sequencer (MS)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(c/(a+b+c+d))</formula>
    </metric>

    <metric name="metric_% Uops delivered from loop stream detector (LSD)">
        <event alias="a">IDQ.DSB_UOPS</event>
        <event alias="b">IDQ.MITE_UOPS</event>
        <event alias="c">IDQ.MS_UOPS</event>
        <event alias="d">LSD.UOPS</event>
        <formula>100*(d/(a+b+c+d))</formula>
    </metric>
	
	<metric name="metric_FP scalar single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP scalar single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_FP scalar double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP scalar double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_FP 128-bit packed single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 128-bit packed single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 128-bit packed double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 128-bit packed double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 256-bit packed single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 256-bit packed single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 256-bit packed double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 256-bit packed double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_FP 512-bit packed single-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 512-bit packed single-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>
		
	<metric name="metric_FP 512-bit packed double-precision FP instructions retired per instr">
        <throughput-metric-name>metric_FP 512-bit packed double-precision FP instructions retired per txn</throughput-metric-name>
		<event alias="a">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
		<event alias="b">INST_RETIRED.ANY</event>
		<formula>a/b</formula>
	</metric>

	<metric name="metric_DRAM power (watts)">
		<event alias="a">MSR_EVENT:msr=0x619:type=FREERUN:scope=PACKAGE</event>
		<formula>a*15.3/1000000</formula>
	</metric>
	
	<metric name="metric_package power (watts)">
		<event alias="a">MSR_EVENT:msr=0x611:type=FREERUN:scope=PACKAGE</event>
		<formula>a*61/1000000</formula>
	</metric>

	<metric name="metric_core c6 residency %">
		<event alias="a">MSR_EVENT:msr=0x3FD:type=FREERUN:scope=THREAD</event>
		<event alias="b">TSC</event>
		<formula>100*a/b</formula>
	</metric>

	<metric name="metric_package c2 residency %">
		<event alias="a">MSR_EVENT:msr=0x60D:type=FREERUN:scope=PACKAGE</event>
		<event alias="b">TSC</event>
		<constant alias="cpu_count">system.sockets[0].cpus.count</constant>      
		<formula>100*a*cpu_count/b</formula>
	</metric>
	
	<metric name="metric_package c6 residency %">
		<event alias="a">MSR_EVENT:msr=0x3F9:type=FREERUN:scope=PACKAGE</event>
		<event alias="b">TSC</event>
		<constant alias="cpu_count">system.sockets[0].cpus.count</constant>      
		<formula>100*a*cpu_count/b</formula>
	</metric>
	
	<metric name="metric_core clflush and clflushopt per instr">
        <throughput-metric-name>metric_core clflush and clflushopt per txn</throughput-metric-name>
		<event alias="a">UNC_CHA_TOR_INSERTS.IA_CLFLUSH</event>
		<event alias="b">UNC_CHA_TOR_INSERTS.IA_CLFLUSHOPT</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>(a+b)/c</formula>
	</metric>

	<metric name="metric_core PAUSE instr executions per instr">
        <throughput-metric-name>metric_core PAUSE instr executions per txn</throughput-metric-name>
		<event alias="a">MISC_RETIRED.PAUSE_INST</event>
		<event alias="c">INST_RETIRED.ANY</event>
		<formula>a/c</formula>
	</metric>

	<metric name="metric_core % cycles in non AVX license">
		<event alias="a">CORE_POWER.LVL0_TURBO_LICENSE</event>
		<event alias="b">CORE_POWER.LVL1_TURBO_LICENSE</event>
		<event alias="c">CORE_POWER.LVL2_TURBO_LICENSE</event>
		<formula>100*a/(a+b+c)</formula>
	</metric>

	<metric name="metric_core % cycles in AVX2 license">
		<event alias="a">CORE_POWER.LVL0_TURBO_LICENSE</event>
		<event alias="b">CORE_POWER.LVL1_TURBO_LICENSE</event>
		<event alias="c">CORE_POWER.LVL2_TURBO_LICENSE</event>
		<formula>100*b/(a+b+c)</formula>
	</metric>

	<metric name="metric_core % cycles in AVX-512 license">
		<event alias="a">CORE_POWER.LVL0_TURBO_LICENSE</event>
		<event alias="b">CORE_POWER.LVL1_TURBO_LICENSE</event>
		<event alias="c">CORE_POWER.LVL2_TURBO_LICENSE</event>
		<formula>100*c/(a+b+c)</formula>
	</metric>

  <metric name="metric_TMA_Frontend_Bound(%)">
    <event alias="a">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="b">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">TOPDOWN.SLOTS</event>
    <formula>100 * ( a / ( ( a + b + c + d ) ) - e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Frontend_Latency(%)">
    <event alias="a">IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE</event>
    <event alias="b">FRONTEND_RETIRED.LATENCY_GE_1</event>
    <event alias="c">FRONTEND_RETIRED.LATENCY_GE_2</event>
    <event alias="d">UOPS_RETIRED.SLOTS</event>
    <event alias="e">UOPS_ISSUED.ANY</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">TOPDOWN.SLOTS</event>
    <formula>100 * ( ( 5 ) * ( a - ( b - c ) / ( ( d ) / e ) ) / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....ICache_Misses(%)">
    <event alias="a">ICACHE_16B.IFDATA_STALL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....ITLB_Misses(%)">
    <event alias="a">ICACHE_64B.IFTAG_STALL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....Branch_Resteers(%)">
    <event alias="a">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="b">BACLEARS.ANY</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a + ( 10 ) * b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_......Mispredicts_Resteers(%)">
    <event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="b">MACHINE_CLEARS.COUNT</event>
    <event alias="c">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a / ( a + b ) ) * c / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_......Clears_Resteers(%)">
    <event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="b">MACHINE_CLEARS.COUNT</event>
    <event alias="c">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 1 - ( a / ( a + b ) ) ) * c / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_......Unknown_Branches(%)">
    <event alias="a">INT_MISC.CLEAR_RESTEER_CYCLES</event>
    <event alias="b">BACLEARS.ANY</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( a + ( 10 ) * b ) / ( c ) ) - a / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_....DSB_Switches(%)">
    <event alias="a">DSB2MITE_SWITCHES.PENALTY_CYCLES</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....LCP(%)">
    <event alias="a">ILD_STALL.LCP</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....MS_Switches(%)">
    <event alias="a">IDQ.MS_SWITCHES</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 3 ) * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..Frontend_Bandwidth(%)">
    <event alias="a">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="b">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">TOPDOWN.SLOTS</event>
    <event alias="h">IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE</event>
    <event alias="i">FRONTEND_RETIRED.LATENCY_GE_1</event>
    <event alias="j">FRONTEND_RETIRED.LATENCY_GE_2</event>
    <event alias="k">UOPS_RETIRED.SLOTS</event>
    <event alias="l">UOPS_ISSUED.ANY</event>
    <formula>100 * ( ( ( 0 ) &gt; ( ( a / ( ( a + b + c + d ) ) - e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) - ( ( 5 ) * ( h - ( i - j ) / ( ( k ) / l ) ) / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) ) ) ? ( 0 ) : ( ( a / ( ( a + b + c + d ) ) - e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) - ( ( 5 ) * ( h - ( i - j ) / ( ( k ) / l ) ) / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....MITE(%)">
    <event alias="a">IDQ.MITE_CYCLES_ANY</event>
    <event alias="b">IDQ.MITE_CYCLES_OK</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a - b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_....DSB(%)">
    <event alias="a">IDQ.DSB_CYCLES_ANY</event>
    <event alias="b">IDQ.DSB_CYCLES_OK</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a - b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_....LSD(%)">
    <event alias="a">LSD.CYCLES_ACTIVE</event>
    <event alias="b">LSD.CYCLES_OK</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a - b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_Bad_Speculation(%)">
    <event alias="a">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">TOPDOWN.SLOTS</event>
    <formula>100 * ( a / ( ( b + a + c + d ) ) + e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Branch_Mispredicts(%)">
    <event alias="a">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="b">MACHINE_CLEARS.COUNT</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="e">PERF_METRICS.RETIRING</event>
    <event alias="f">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="g">INT_MISC.UOP_DROPPING</event>
    <event alias="h">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="i">TOPDOWN.SLOTS</event>
    <formula>100 * ( ( a / ( a + b ) ) * ( c / ( ( d + c + e + f ) ) + g / ( ( ( h - 0 ) &gt; 0 ) ? ( h ) : ( i ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Machine_Clears(%)">
    <event alias="a">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.RETIRING</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">INT_MISC.UOP_DROPPING</event>
    <event alias="f">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="g">TOPDOWN.SLOTS</event>
    <event alias="h">BR_MISP_RETIRED.ALL_BRANCHES</event>
    <event alias="i">MACHINE_CLEARS.COUNT</event>
    <formula>100 * ( ( ( 0 ) &gt; ( ( a / ( ( b + a + c + d ) ) + e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) - ( ( h / ( h + i ) ) * ( a / ( ( b + a + c + d ) ) + e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) ) ) ) ? ( 0 ) : ( ( a / ( ( b + a + c + d ) ) + e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) - ( ( h / ( h + i ) ) * ( a / ( ( b + a + c + d ) ) + e / ( ( ( f - 0 ) &gt; 0 ) ? ( f ) : ( g ) ) ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_Backend_Bound(%)">
    <event alias="a">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.RETIRING</event>
    <formula>100 * ( a / ( ( b + c + d + a ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Memory_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="b">EXE_ACTIVITY.BOUND_ON_STORES</event>
    <event alias="c">EXE_ACTIVITY.EXE_BOUND_0_PORTS</event>
    <event alias="d">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="e">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <event alias="f">UOPS_RETIRED.SLOTS</event>
    <event alias="g">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="h">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="i">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="j">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="k">PERF_METRICS.RETIRING</event>
    <formula>100 * ( ( ( a + b ) / ( ( c + d + ( e * ( ( ( f ) / ( g ) ) / ( ( 5 ) + 1 ) ) ) ) + ( a + b ) ) ) * ( h / ( ( i + j + k + h ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....L1_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="b">CYCLE_ACTIVITY.STALLS_L1D_MISS</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a - b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_......DTLB_Load(%)">
    <event alias="a">DTLB_LOAD_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( 7 ) * a + b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_........Load_STLB_Hit(%)">
    <event alias="a">DTLB_LOAD_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( ( 7 ) * a + b ) / ( c ) ) - ( b / ( c ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Load_STLB_Miss(%)">
    <event alias="a">DTLB_LOAD_MISSES.WALK_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Store_Fwd_Blk(%)">
    <event alias="a">LD_BLOCKS.STORE_FORWARD</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( 13 * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Lock_Latency(%)">
    <event alias="a">MEM_INST_RETIRED.LOCK_LOADS</event>
    <event alias="b">MEM_INST_RETIRED.ALL_STORES</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="d">OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DEMAND_RFO</event>
    <formula>100 * ( ( a / b ) * ( ( ( c - 0 ) &lt; ( d ) ) ? ( c ) : ( d ) ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_......Split_Loads(%)">
    <event alias="a">L1D_PEND_MISS.PENDING</event>
    <event alias="b">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="c">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="d">LD_BLOCKS.NO_SR</event>
    <event alias="e">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a / ( b + c ) ) * d / ( e ) )</formula>
  </metric>
  <metric name="metric_TMA_......4K_Aliasing(%)">
    <event alias="a">LD_BLOCKS_PARTIAL.ADDRESS_ALIAS</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......FB_Full(%)">
    <event alias="a">L1D_PEND_MISS.FB_FULL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....L2_Bound(%)">
    <event alias="a">MEM_LOAD_RETIRED.L2_HIT</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">L1D_PEND_MISS.FB_FULL_PERIODS</event>
    <event alias="e">CYCLE_ACTIVITY.STALLS_L1D_MISS</event>
    <event alias="f">CYCLE_ACTIVITY.STALLS_L2_MISS</event>
    <event alias="g">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( a * ( 1 + b / ( c ) ) ) / ( ( a * ( 1 + b / ( c ) ) ) + d ) ) * ( ( e - f ) / ( g ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....L3_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_L2_MISS</event>
    <event alias="b">CYCLE_ACTIVITY.STALLS_L3_MISS</event>
    <event alias="c">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( a - b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_......Contested_Accesses(%)">
    <event alias="a">MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HITM</event>
    <event alias="e">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HIT_WITH_FWD</event>
    <event alias="f">MEM_LOAD_L3_HIT_RETIRED.XSNP_MISS</event>
    <event alias="g">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( 60 ) * ( a * ( 1 + b / ( c ) ) * ( d / ( d + e ) ) ) + ( 43 ) * ( f * ( 1 + b / ( c ) ) ) ) / ( g ) )</formula>
  </metric>
  <metric name="metric_TMA_......Data_Sharing(%)">
    <event alias="a">MEM_LOAD_L3_HIT_RETIRED.XSNP_HIT</event>
    <event alias="b">MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM</event>
    <event alias="c">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HITM</event>
    <event alias="d">OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HIT_WITH_FWD</event>
    <event alias="e">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="f">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="g">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 43 ) * ( ( a + b * ( 1 - ( c / ( c + d ) ) ) ) * ( 1 + e / ( f ) ) ) / ( g ) )</formula>
  </metric>
  <metric name="metric_TMA_......L3_Hit_Latency(%)">
    <event alias="a">MEM_LOAD_RETIRED.L3_HIT</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 41 ) * ( a * ( 1 + b / ( c ) ) ) / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_......SQ_Full(%)">
    <event alias="a">L1D_PEND_MISS.L2_STALL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....DRAM_Bound(%)">
    <event alias="a">CYCLE_ACTIVITY.STALLS_L3_MISS</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="c">CYCLE_ACTIVITY.STALLS_L1D_MISS</event>
    <event alias="d">CYCLE_ACTIVITY.STALLS_L2_MISS</event>
    <event alias="e">MEM_LOAD_RETIRED.L2_HIT</event>
    <event alias="f">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="g">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="h">L1D_PEND_MISS.FB_FULL_PERIODS</event>
    <formula>100 * ( ( a / ( b ) + ( ( c - d ) / ( b ) ) - ( ( ( e * ( 1 + f / ( g ) ) ) / ( ( e * ( 1 + f / ( g ) ) ) + h ) ) * ( ( c - d ) / ( b ) ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......MEM_Bandwidth(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD:c4</event>
    <formula>100 * ( ( ( ( a - 0 ) &lt; ( b ) ) ? ( a ) : ( b ) ) / ( a ) )</formula>
  </metric>
  <metric name="metric_TMA_......MEM_Latency(%)">
    <event alias="a">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="b">OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DATA_RD</event>
    <event alias="c">OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD:c4</event>
    <formula>100 * ( ( ( ( a - 0 ) &lt; ( b ) ) ? ( a ) : ( b ) ) / ( a ) - ( ( ( ( a - 0 ) &lt; ( c ) ) ? ( a ) : ( c ) ) / ( a ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Local_DRAM(%)">
    <event alias="a">MEM_LOAD_L3_MISS_RETIRED.LOCAL_DRAM</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 200 ) * ( a * ( 1 + b / ( c ) ) ) / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_........Remote_DRAM(%)">
    <event alias="a">MEM_LOAD_L3_MISS_RETIRED.REMOTE_DRAM</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 310 ) * ( a * ( 1 + b / ( c ) ) ) / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_........Remote_Cache(%)">
    <event alias="a">MEM_LOAD_L3_MISS_RETIRED.REMOTE_HITM</event>
    <event alias="b">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="c">MEM_LOAD_RETIRED.L1_MISS</event>
    <event alias="d">MEM_LOAD_L3_MISS_RETIRED.REMOTE_FWD</event>
    <event alias="e">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( 200 ) * ( a * ( 1 + b / ( c ) ) ) + ( 180 ) * ( d * ( 1 + b / ( c ) ) ) ) / ( e ) )</formula>
  </metric>
  <metric name="metric_TMA_....Store_Bound(%)">
    <event alias="a">EXE_ACTIVITY.BOUND_ON_STORES:c1</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Store_Latency(%)">
    <event alias="a">L2_RQSTS.RFO_HIT</event>
    <event alias="b">MEM_INST_RETIRED.LOCK_LOADS</event>
    <event alias="c">MEM_INST_RETIRED.ALL_STORES</event>
    <event alias="d">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="e">OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DEMAND_RFO</event>
    <formula>100 * ( ( ( a * ( 10 ) * ( 1 - ( b / c ) ) ) + ( 1 - ( b / c ) ) * ( ( ( d - 0 ) &lt; ( e ) ) ? ( d ) : ( e ) ) ) / ( d ) )</formula>
  </metric>
  <metric name="metric_TMA_......False_Sharing(%)">
    <event alias="a">OCR.DEMAND_RFO.L3_HIT.SNOOP_HITM</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( 60 ) * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Split_Stores(%)">
    <event alias="a">MEM_INST_RETIRED.SPLIT_STORES</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......DTLB_Store(%)">
    <event alias="a">DTLB_STORE_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_STORE_MISSES.WALK_ACTIVE</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( ( 7 ) * a + b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_........Store_STLB_Hit(%)">
    <event alias="a">DTLB_STORE_MISSES.STLB_HIT</event>
    <event alias="b">DTLB_STORE_MISSES.WALK_ACTIVE</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( ( ( 7 ) * a + b ) / ( c ) ) - ( b / ( c ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Store_STLB_Miss(%)">
    <event alias="a">DTLB_STORE_MISSES.WALK_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..Core_Bound(%)">
    <event alias="a">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.RETIRING</event>
    <event alias="e">CYCLE_ACTIVITY.STALLS_MEM_ANY</event>
    <event alias="f">EXE_ACTIVITY.BOUND_ON_STORES</event>
    <event alias="g">EXE_ACTIVITY.EXE_BOUND_0_PORTS</event>
    <event alias="h">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="i">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <event alias="j">UOPS_RETIRED.SLOTS</event>
    <event alias="k">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( ( ( 0 ) &gt; ( ( a / ( ( b + c + d + a ) ) ) - ( ( ( e + f ) / ( ( g + h + ( i * ( ( ( j ) / ( k ) ) / ( ( 5 ) + 1 ) ) ) ) + ( e + f ) ) ) * ( a / ( ( b + c + d + a ) ) ) ) ) ) ? ( 0 ) : ( ( a / ( ( b + c + d + a ) ) ) - ( ( ( e + f ) / ( ( g + h + ( i * ( ( ( j ) / ( k ) ) / ( ( 5 ) + 1 ) ) ) ) + ( e + f ) ) ) * ( a / ( ( b + c + d + a ) ) ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....Divider(%)">
    <event alias="a">ARITH.DIVIDER_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_....Ports_Utilization(%)">
    <event alias="a">EXE_ACTIVITY.EXE_BOUND_0_PORTS</event>
    <event alias="b">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="c">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <event alias="d">UOPS_RETIRED.SLOTS</event>
    <event alias="e">CPU_CLK_UNHALTED.THREAD</event>
    <event alias="f">ARITH.DIVIDER_ACTIVE</event>
    <formula>100 * ( ( ( ( f - 0 ) &lt; a ) ) ? ( ( a + b + ( c * ( ( ( d ) / ( e ) ) / ( ( 5 ) + 1 ) ) ) ) / ( e ) ) : ( ( ( a + b + ( c * ( ( ( d ) / ( e ) ) / ( ( 5 ) + 1 ) ) ) ) - a ) / ( e ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_0(%)">
    <event alias="a">EXE_ACTIVITY.EXE_BOUND_0_PORTS</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_........Serializing_Operation(%)">
    <event alias="a">RESOURCE_STALLS.SCOREBOARD</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Slow_Pause(%)">
    <event alias="a">MISC_RETIRED.PAUSE_INST</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( 146 * a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_1(%)">
    <event alias="a">EXE_ACTIVITY.1_PORTS_UTIL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_2(%)">
    <event alias="a">EXE_ACTIVITY.2_PORTS_UTIL</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_......Ports_Utilized_3m(%)">
    <event alias="a">UOPS_EXECUTED.CYCLES_GE_3</event>
    <event alias="b">CPU_CLK_UNHALTED.THREAD</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_........ALU_Op_Utilization(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_0</event>
    <event alias="b">UOPS_DISPATCHED.PORT_1</event>
    <event alias="c">UOPS_DISPATCHED.PORT_5</event>
    <event alias="d">UOPS_DISPATCHED.PORT_6</event>
    <event alias="e">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a + b + c + d ) / ( 4 * ( e ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_0(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_0</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_1(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_1</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_5(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_5</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_..........Port_6(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_6</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( b ) )</formula>
  </metric>
  <metric name="metric_TMA_........Load_Op_Utilization(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_2_3</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( a / ( 2 * ( b ) ) )</formula>
  </metric>
  <metric name="metric_TMA_........Store_Op_Utilization(%)">
    <event alias="a">UOPS_DISPATCHED.PORT_4_9</event>
    <event alias="b">UOPS_DISPATCHED.PORT_7_8</event>
    <event alias="c">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>100 * ( ( a + b ) / ( 4 * ( c ) ) )</formula>
  </metric>
  <metric name="metric_TMA_Retiring(%)">
    <event alias="a">PERF_METRICS.RETIRING</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <formula>100 * ( a / ( ( b + c + a + d ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Base(%)">
    <event alias="a">PERF_METRICS.RETIRING</event>
    <event alias="b">PERF_METRICS.FRONTEND_BOUND</event>
    <event alias="c">PERF_METRICS.BAD_SPECULATION</event>
    <event alias="d">PERF_METRICS.BACKEND_BOUND</event>
    <event alias="e">UOPS_RETIRED.SLOTS</event>
    <event alias="f">UOPS_ISSUED.ANY</event>
    <event alias="g">IDQ.MS_UOPS</event>
    <event alias="h">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="i">TOPDOWN.SLOTS</event>
    <formula>100 * ( ( ( 0 ) &gt; ( ( a / ( ( b + c + a + d ) ) ) - ( ( ( e ) / f ) * g / ( ( ( h - 0 ) &gt; 0 ) ? ( h ) : ( i ) ) ) ) ) ? ( 0 ) : ( ( a / ( ( b + c + a + d ) ) ) - ( ( ( e ) / f ) * g / ( ( ( h - 0 ) &gt; 0 ) ? ( h ) : ( i ) ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....FP_Arith(%)">
    <event alias="a">UOPS_EXECUTED.X87</event>
    <event alias="b">UOPS_EXECUTED.THREAD</event>
    <event alias="c">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="e">UOPS_RETIRED.SLOTS</event>
    <event alias="f">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="g">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="h">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="i">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="j">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="k">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <formula>100 * ( ( a / b ) + ( ( c + d ) / ( e ) ) + ( ( f + g + h + i + j + k ) / ( e ) ) )</formula>
  </metric>
  <metric name="metric_TMA_......X87_Use(%)">
    <event alias="a">UOPS_EXECUTED.X87</event>
    <event alias="b">UOPS_EXECUTED.THREAD</event>
    <formula>100 * ( a / b )</formula>
  </metric>
  <metric name="metric_TMA_......FP_Scalar(%)">
    <event alias="a">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="b">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="c">UOPS_RETIRED.SLOTS</event>
    <formula>100 * ( ( a + b ) / ( c ) )</formula>
  </metric>
  <metric name="metric_TMA_......FP_Vector(%)">
    <event alias="a">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="b">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="c">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="e">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="f">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <event alias="g">UOPS_RETIRED.SLOTS</event>
    <formula>100 * ( ( a + b + c + d + e + f ) / ( g ) )</formula>
  </metric>
  <metric name="metric_TMA_....Other(%)">
    <event alias="a">UOPS_EXECUTED.X87</event>
    <event alias="b">UOPS_EXECUTED.THREAD</event>
    <event alias="c">FP_ARITH_INST_RETIRED.SCALAR_SINGLE</event>
    <event alias="d">FP_ARITH_INST_RETIRED.SCALAR_DOUBLE</event>
    <event alias="e">UOPS_RETIRED.SLOTS</event>
    <event alias="f">FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE</event>
    <event alias="g">FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE</event>
    <event alias="h">FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE</event>
    <event alias="i">FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE</event>
    <event alias="j">FP_ARITH_INST_RETIRED.512B_PACKED_DOUBLE</event>
    <event alias="k">FP_ARITH_INST_RETIRED.512B_PACKED_SINGLE</event>
    <formula>100 * ( 1 - ( ( a / b ) + ( ( c + d ) / ( e ) ) + ( ( f + g + h + i + j + k ) / ( e ) ) ) )</formula>
  </metric>
  <metric name="metric_TMA_..Microcode_Sequencer(%)">
    <event alias="a">UOPS_RETIRED.SLOTS</event>
    <event alias="b">UOPS_ISSUED.ANY</event>
    <event alias="c">IDQ.MS_UOPS</event>
    <event alias="d">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="e">TOPDOWN.SLOTS</event>
    <formula>100 * ( ( ( a ) / b ) * c / ( ( ( d - 0 ) &gt; 0 ) ? ( d ) : ( e ) ) )</formula>
  </metric>
  <metric name="metric_TMA_....Assists(%)">
    <event alias="a">ASSISTS.ANY</event>
    <event alias="b">TOPDOWN.SLOTS:perf_metrics</event>
    <event alias="c">TOPDOWN.SLOTS</event>
    <formula>100 * ( ( 100 ) * a / ( ( ( b - 0 ) &gt; 0 ) ? ( b ) : ( c ) ) )</formula>
  </metric>

	<metric name="metric_TMA__info_CoreIPC">
    <event alias="a">INST_RETIRED.ANY</event>
    <event alias="b">CPU_CLK_UNHALTED.DISTRIBUTED</event>
    <formula>a / ( b )</formula>
  </metric>

    <metric name="metric_TMA__info_ILP">
    <event alias="a">UOPS_EXECUTED.THREAD</event>
    <event alias="b">UOPS_EXECUTED.CORE_CYCLES_GE_1</event>
		<constant alias="threads">system.sockets[0][0].size</constant>      
    <formula>a / ( ( (threads-0) &gt; 1 ) ? ( ( b / 2 ) ) : ( b ) )</formula>
  </metric>
  <metric name="metric_TMA__info_Load_Miss_Real_Latency(cycles)">
    <event alias="a">L1D_PEND_MISS.PENDING</event>
    <event alias="c">MEM_LOAD_RETIRED.FB_HIT</event>
    <event alias="b">MEM_LOAD_RETIRED.L1_MISS</event>
    <formula>a / ( b + c )</formula>
  </metric>
  <metric name="metric_TMA__info_MLP">
    <event alias="a">L1D_PEND_MISS.PENDING</event>
    <event alias="b">L1D_PEND_MISS.PENDING_CYCLES</event>
    <formula>a / b</formula>
  </metric>
  <metric name="metric_TMA__info_SMT_2T_Utilization">
    <event alias="a">CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE</event>
    <event alias="b">CPU_CLK_UNHALTED.REF_DISTRIBUTED</event>
		<constant alias="threads">system.sockets[0][0].size</constant>      
    <formula>( (threads-0) &gt; 1 ) ? ( 1 - a / b ) : ( 0 )</formula>
  </metric>
  <metric name="metric_EDP ICX XML version">
 		<constant alias="version">4.1</constant>      
		<formula>version</formula>
   </metric>

  </root>
